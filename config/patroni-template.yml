ttl: &ttl 30
loop_wait: &loop_wait 10
scope: &scope ${PATRONI_SCOPE}
restapi:
  listen: 0.0.0.0:8008
  connect_address: ${connect_address_8008}
etcd:
  scope: *scope
  ttl: *ttl
  host: ${ETCD_HOST_PORT}
postgresql:
  name: ${NODE_ID//./_} ## Replication slots do not allow dots in their name
  scope: *scope
  listen: 0.0.0.0:5432
  connect_address: ${connect_address_5432}
  data_dir: ${PG_DATA_DIR}
  maximum_lag_on_failover: 1048576 # 1 megabyte in bytes
  use_slots: False
  pgpass: /tmp/pgpass
  # pg_rewind:
  #   username: postgres
  #   password: starkandwayne
  pg_hba:
  # Allow any user from any host to connect to database
  # "postgres" if the user's password is correctly supplied.
  # TYPE    DATABASE     USER            ADDRESS   METHOD
  - host    replication  ${APPUSER_USERNAME}  0.0.0.0/0 md5
  - host    postgres     all             0.0.0.0/0 md5
  # hostssl entry can only be turned on if  ssl: "on" is set
  # - hostssl postgres     all             0.0.0.0/0 md5
  replication: # replication username, user will be created during initialization
    username: ${APPUSER_USERNAME}
    password: ${APPUSER_PASSWORD}
    network:  127.0.0.1/32
  superuser:
    username: ${SUPERUSER_USERNAME}
    password: ${SUPERUSER_PASSWORD} # password for postgres user. It would be set during initialization
  admin: # user will be created during initialization. It would have CREATEDB and CREATEROLE privileges
    username: ${ADMIN_USERNAME}
    password: ${ADMIN_PASSWORD}
  create_replica_method: ${replica_methods}
EOF

  if [[ "${WALE_CMD}X" != "X" ]]; then
    cat <<EOF >>/patroni/postgres.yml
  wal_e:
    command: /patroni/scripts/wale_restore.py
    # {key: value} below are converted to options for wale_restore.py script
    envdir: ${WALE_ENV_DIR}
    threshold_megabytes: 10240
    threshold_backup_size_percentage: 30
    retries: 2
    use_iam: 0
    no_master: 1
  recovery_conf:
    restore_command: ${restore_command}
EOF
fi

  cat <<EOF >>/patroni/postgres.yml
  # parameters are converted into --<name> <value> flags on the server command line
  parameters:
    # http://www.postgresql.org/docs/9.5/static/runtime-config-connection.html
    listen_addresses: 0.0.0.0
    port: 5432
    max_connections: 100
    # ssl: "on"
    # ssl_cert_file: "$SSL_CERTIFICATE"
    # ssl_key_file: "$SSL_PRIVATE_KEY"

    # http://www.postgresql.org/docs/9.5/static/runtime-config-wal.html
    wal_level: hot_standby
    wal_log_hints: "on"
    archive_mode: "${archive_mode}"
    archive_command: ${archive_command}
    archive_timeout: 10min

    # http://www.postgresql.org/docs/9.5/static/runtime-config-replication.html
    # - sending servers config
    max_wal_senders: 5
    max_replication_slots: 5
    max_wal_size: 1GB
    min_wal_size: 128MB
    wal_keep_segments: 8
    # - standby servers config
    hot_standby: "on"
    wal_log_hints: "on"

    # When using synchronous replication, use at least three Postgres data nodes
    # to ensure write availability if one host fails.
    # To enable a simple synchronous replication test:
    # synchronous_commit: "on"
    # synchronous_standby_names: "*"
